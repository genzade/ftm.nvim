describe('Term', function()
  local U = require('ftm.utils')
  local Term = require('ftm.terminal')

  describe('new()', function()
    it('returns a table with expected default fields', function()
      local term = Term:new()
      assert.is_table(term)
      assert.is_nil(term.win)
      assert.is_nil(term.buf)
      assert.is_nil(term.terminal)
      assert.are.same(U.defaults, term.config)
    end)

    it('sets metatable __index to Term', function()
      local term = Term:new()
      local mt = getmetatable(term)
      assert.are.equal(Term, mt.__index)
    end)
  end)

  describe('setup()', function()
    before_each(function()
      stub(vim, 'notify')
    end)

    after_each(function()
      vim.notify:revert()
    end)

    it('notifies and returns self when cfg is nil', function()
      local term = setmetatable({}, { __index = Term })
      local result = term:setup(nil)
      assert.are.equal(term, result)
      assert
        .stub(vim.notify)
        .was_called_with('[FTM] setup() is optional. Please remove it!', vim.log.levels.WARN, { title = 'FTM' })
    end)

    it('does nothing when cfg is provided', function()
      local term = Term:new()
      assert.has_no.errors(function()
        term:setup({ foo = 'bar' })
      end)
    end)
  end)

  describe('store()', function()
    it('stores win and buf and returns self', function()
      local term = setmetatable({}, { __index = Term })
      local win = 42
      local buf = 99
      local result = term:store(win, buf)
      assert.are.equal(win, term.win)
      assert.are.equal(buf, term.buf)
      assert.are.equal(term, result)
    end)

    it('overwrites previous win and buf values', function()
      local term = setmetatable({ win = 1, buf = 2 }, { __index = Term })
      local result = term:store(3, 4)
      assert.are.equal(3, term.win)
      assert.are.equal(4, term.buf)
      assert.are.equal(term, result)
    end)
  end)

  describe('remember_cursor()', function()
    before_each(function()
      stub(vim.api, 'nvim_get_current_win').returns(10)
      stub(vim.fn, 'winnr').returns(5)
      stub(vim.api, 'nvim_win_get_cursor').returns({ 7, 3 })
    end)

    after_each(function()
      vim.api.nvim_get_current_win:revert()
      vim.fn.winnr:revert()
      vim.api.nvim_win_get_cursor:revert()
    end)

    it('stores last_win, prev_win, and last_pos and returns self', function()
      local term = setmetatable({}, { __index = Term })
      local result = term:remember_cursor()

      assert.are.equal(10, term.last_win)
      assert.are.equal(5, term.prev_win)
      assert.are.same({ 7, 3 }, term.last_pos)
      assert.are.equal(term, result)
    end)
  end)

  describe('restore_cursor()', function()
    before_each(function()
      stub(vim, 'cmd')
      stub(U, 'is_win_valid').returns(true)
      stub(vim.api, 'nvim_set_current_win')
      stub(vim.api, 'nvim_win_set_cursor')
    end)

    after_each(function()
      -- Revert stubs after each test
      vim.cmd:revert()
      U.is_win_valid:revert()
      vim.api.nvim_set_current_win:revert()
      vim.api.nvim_win_set_cursor:revert()
    end)

    it('restores cursor when last_win and last_pos are set and prev_win > 0', function()
      local term = setmetatable({
        last_win = 11,
        last_pos = { 8, 2 },
        prev_win = 3,
      }, { __index = Term })

      local result = term:restore_cursor()

      assert.stub(vim.cmd).was_called_with('silent! 3 wincmd w')
      assert.stub(U.is_win_valid).was_called_with(11)
      assert.stub(vim.api.nvim_set_current_win).was_called_with(11)
      assert.stub(vim.api.nvim_win_set_cursor).was_called_with(11, { 8, 2 })
      assert.is_nil(term.last_win)
      assert.is_nil(term.prev_win)
      assert.is_nil(term.last_pos)
      assert.are.equal(term, result)
    end)

    it('does nothing if last_win or last_pos is nil', function()
      local term = setmetatable({ last_win = nil, last_pos = nil }, { __index = Term })
      assert.are.equal(term, term:restore_cursor())
    end)
  end)

  describe('create_buf()', function()
    context('when previous buffer is valid', function()
      before_each(function()
        stub(U, 'is_buf_valid').returns(true)
      end)

      after_each(function()
        U.is_buf_valid:revert()
      end)

      it('returns previous buffer if valid', function()
        local term = setmetatable({ buf = 101 }, { __index = Term })
        local result = term:create_buf()
        assert.are.equal(101, result)
      end)
    end)

    context('when previous buffer is not valid', function()
      before_each(function()
        stub(U, 'is_buf_valid').returns(false)
        stub(vim.api, 'nvim_create_buf').returns(202)
        stub(vim.api, 'nvim_set_option_value')
      end)

      after_each(function()
        U.is_buf_valid:revert()
        vim.api.nvim_create_buf:revert()
        vim.api.nvim_set_option_value:revert()
      end)

      it('creates a new buffer and sets filetype if previous buffer is not valid', function()
        local term = setmetatable({
          buf = nil,
          config = { ft = 'FTM' },
        }, { __index = Term })
        local result = term:create_buf()

        assert.are.equal(202, result)
        assert.stub(vim.api.nvim_set_option_value).was_called_with('filetype', 'FTM', { buf = 202 })
      end)
    end)
  end)

  describe('resize()', function()
    it('returns self', function()
      local term = setmetatable({}, { __index = Term })
      local result = term:resize()
      assert.are.equal(term, result)
    end)

    it('does not error when win is nil', function()
      local term = setmetatable({ win = nil }, { __index = Term })
      assert.has_no.errors(function()
        term:resize()
      end)
    end)

    it('does not error when config is missing', function()
      local term = setmetatable({ win = 1 }, { __index = Term })
      term.config = nil
      assert.has_no.errors(function()
        term:resize()
      end)
    end)
  end)

  describe('open()', function()
    local term

    before_each(function()
      term = Term:new()
      stub(U, 'is_win_valid')
      stub(term, 'remember_cursor')
      stub(term, 'create_buf')
      stub(term, 'create_win')
      stub(term, 'store')
      stub(term, 'prompt')
      stub(term, 'open_term')
      term.win = 1
      term.buf = 2
    end)

    after_each(function()
      U.is_win_valid:revert()
      term.remember_cursor:revert()
      term.create_buf:revert()
      term.create_win:revert()
      term.store:revert()
      term.prompt:revert()
      term.open_term:revert()
    end)

    context('when existing window is valid', function()
      before_each(function()
        U.is_win_valid.returns(true)
      end)

      it('moves to existing window if valid', function()
        local set_current_win = stub(vim.api, 'nvim_set_current_win')
        term:open()
        assert.stub(set_current_win).was_called_with(term.win)
        set_current_win:revert()
      end)
    end)

    context('when existing window is invalid', function()
      before_each(function()
        U.is_win_valid.returns(false)
      end)

      it('toggles terminal if buffer matches', function()
        term.create_buf.returns(term.buf)
        term.create_win.returns(3)
        term.store.returns(term)
        term.prompt.returns('prompted')
        local result = term:open()
        assert.equals('prompted', result)
        assert.stub(term.prompt).was_called()
      end)

      it('opens new terminal if buffer does not match', function()
        term.create_buf.returns(99)
        term.create_win.returns(3)
        term.store.returns(term)
        term.open_term.returns('opened')
        local result = term:open()
        assert.equals('opened', result)
        assert.stub(term.open_term).was_called()
      end)
    end)
  end)
end)
